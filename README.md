# temp_library


Документация по моделям и запросам для книжного магазина на Django
1. Описание моделей и связей
Модель AuditModel
Абстрактная базовая модель, используемая для хранения информации о создании и изменении записей. Поля:

creator: Ссылка на пользователя (User), который создал или изменил запись. Использует ForeignKey с on_delete=models.PROTECT, чтобы предотвратить удаление пользователя, если он связан с записями.
created_at: Дата и время создания записи, автоматически заполняется при создании (auto_now_add=True).
updated_at: Дата и время последнего изменения записи, обновляется автоматически (auto_now=True).
deleted_at: Поле для мягкого удаления, допускает null и blank.

Эта модель является абстрактной (abstract = True), поэтому не создает таблицу в базе данных, а используется для наследования другими моделями.
Модель Author
Наследуется от AuditModel. Хранит информацию об авторах книг. Поля:

name: Имя автора (строка, максимум 100 символов).
bio: Биография автора (текстовое поле).
Связь: Отсутствуют прямые связи с другими моделями, но используется как ForeignKey в модели Book.

Мета-данные:

verbose_name: "автор", verbose_name_plural: "авторы".
Упорядочивание по полю name.

Модель Book
Наследуется от AuditModel. Хранит информацию о книгах. Поля:

title: Название книги (строка, максимум 200 символов).
author: Ссылка на автора (ForeignKey к Author, on_delete=models.CASCADE). При удалении автора удаляются все его книги.
published_date: Дата публикации книги (тип DateField).
description: Описание книги (текстовое поле).
publisher: Ссылка на издательство (ForeignKey к Publisher, on_delete=models.PROTECT). Удаление издательства запрещено, если с ним связаны книги.
stores: Много-ко-многим связь с моделью Store через ManyToManyField. Указывает, в каких магазинах доступна книга.

Мета-данные:

verbose_name: "книга", verbose_name_plural: "книги".
Упорядочивание по полю title.

Модель Review
Наследуется от AuditModel. Хранит отзывы о книгах. Поля:

rate: Оценка книги (целое число от 0 до 10, ограничено валидаторами MinValueValidator и MaxValueValidator).
comment: Текст отзыва (строка, максимум 1000 символов).
book: Ссылка на книгу (ForeignKey к Book, on_delete=models.CASCADE). При удалении книги удаляются все её отзывы.

Мета-данные:

verbose_name: "отзыв", verbose_name_plural: "отзывы".
Упорядочивание по названию книги (book__title) и оценке (rate).

Модель Publisher
Наследуется от AuditModel. Хранит информацию об издательствах. Поля:

name: Название издательства (строка, максимум 100 символов).
country: Страна издательства (строка, максимум 100 символов).

Мета-данные:

verbose_name: "издательство", verbose_name_plural: "издательства".
Упорядочивание по полям name и country.

Модель Store
Хранит информацию о магазинах. Поля:

name: Название магазина (строка, максимум 100 символов).
city: Город магазина (строка, максимум 100 символов).
Связь: Много-ко-многим с моделью Book через ManyToManyField в модели Book.

Мета-данные:

verbose_name: "магазин", verbose_name_plural: "магазины".
Упорядочивание по полям name и city.
Метод get_absolute_url: Возвращает URL для детального просмотра магазина.

Связи между моделями

Author → Book: Один ко многим (ForeignKey в Book). Один автор может иметь много книг.
Publisher → Book: Один ко многим (ForeignKey в Book). Одно издательство может издавать много книг.
Book → Review: Один ко многим (ForeignKey в Review). Одна книга может иметь много отзывов.
Book ↔ Store: Много ко многим (ManyToManyField в Book). Книга может быть доступна в нескольких магазинах, и магазин может продавать много книг.

2. Инструкции по созданию тестовых данных через административную панель
Для создания тестовых данных через административную панель Django выполните следующие шаги. Предполагается, что вы уже настроили проект, зарегистрировали модели в admin.py и создали суперпользователя (python manage.py createsuperuser).
Шаг 1: Вход в административную панель

Запустите сервер разработки: python manage.py runserver.
Перейдите по адресу http://127.0.0.1:8000/admin/ и войдите, используя учетные данные суперпользователя.

Шаг 2: Создание пользователей

В разделе Users нажмите Add User.
Создайте пользователя:
Username: testuser1
Password: Установите пароль, например, testpassword123.


Сохраните пользователя.
Повторите для второго пользователя, например, testuser2.

Шаг 3: Создание издательств

В разделе Publishers нажмите Add Publisher.
Заполните поля:
Name: Издательство А
Country: Россия
Creator: Выберите testuser1.


Сохраните.
Создайте ещё одно издательство:
Name: Издательство B
Country: США
Creator: Выберите testuser2.



Шаг 4: Создание магазинов

В разделе Stores нажмите Add Store.
Заполните поля:
Name: Книжный мир
City: Москва


Сохраните.
Создайте ещё один магазин:
Name: Библиотека
City: Нью-Йорк



Шаг 5: Создание авторов

В разделе Authors нажмите Add Author.
Заполните поля:
Name: Иван Иванов
Bio: Российский писатель, автор романов.
Creator: Выберите testuser1.


Сохраните.
Создайте второго автора:
Name: John Doe
Bio: Американский писатель, автор детективов.
Creator: Выберите testuser2.



Шаг 6: Создание книг

В разделе Books нажмите Add Book.
Заполните поля:
Title: Роман о времени
Author: Выберите Иван Иванов.
Published_date: 2023-05-15
Description: Исторический роман о судьбе.
Publisher: Выберите Издательство А.
Stores: Выберите Книжный мир.
Creator: Выберите testuser1.


Сохраните.
Создайте вторую книгу:
Title: Тайна ночи
Author: Выберите John Doe.
Published_date: 2022-10-20
Description: Детективный триллер.
Publisher: Выберите Издательство B.
Stores: Выберите Библиотека.
Creator: Выберите testuser2.



Шаг 7: Создание отзывов

В разделе Reviews нажмите Add Review.
Заполните поля:
Book: Выберите Роман о времени.
Rate: 8
Comment: Отличная книга, рекомендую!
Creator: Выберите testuser1.


Сохраните.
Создайте второй отзыв:
Book: Тайна ночи.
Rate: 9
Comment: Захватывающий сюжет!
Creator: Выберите testuser2.



Результат
Теперь у вас есть тестовые данные: 2 пользователя, 2 издательства, 2 магазина, 2 автора, 2 книги и 2 отзыва. Эти данные можно использовать для тестирования запросов.
3. Описание запросов и их логики
start_page

Логика: Получает все книги из базы данных с помощью Book.objects.all() и передает их в шаблон index.html.
Результат: Отображает список всех книг на главной странице.
Особенности: Простой запрос без фильтрации или оптимизации, подходит для небольших баз данных.

get_books_by_country

Логика:
Фильтрует книги по стране издательства (publisher__country=country).
Использует select_related("author", "publisher") для оптимизации загрузки связанных данных об авторе и издателе.
Использует prefetch_related("stores") для оптимизации загрузки связанных магазинов.
Аннотирует:
average_review_rate: Средняя оценка отзывов, округленная до двух знаков (Round(Avg("review__rate"), 2)).
available_in_stores: Количество уникальных магазинов, где доступна книга (Count("stores", distinct=True)).



# Документация по моделям и запросам для книжного магазина на Django

## 1. Описание моделей и связей

### Модель `AuditModel`
Абстрактная базовая модель, используемая для хранения информации о создании и изменении записей. Поля:
- `creator`: Ссылка на пользователя (`User`), который создал или изменил запись. Использует `ForeignKey` с `on_delete=models.PROTECT`, чтобы предотвратить удаление пользователя, если он связан с записями.
- `created_at`: Дата и время создания записи, автоматически заполняется при создании (`auto_now_add=True`).
- `updated_at`: Дата и время последнего изменения записи, обновляется автоматически (`auto_now=True`).
- `deleted_at`: Поле для мягкого удаления, допускает `null` и `blank`.

Эта модель является абстрактной (`abstract = True`), поэтому не создает таблицу в базе данных, а используется для наследования другими моделями.

### Модель `Author`
Наследуется от `AuditModel`. Хранит информацию об авторах книг. Поля:
- `name`: Имя автора (строка, максимум 100 символов).
- `bio`: Биография автора (текстовое поле).
- Связь: Отсутствуют прямые связи с другими моделями, но используется как `ForeignKey` в модели `Book`.

**Мета-данные**:
- `verbose_name`: "автор", `verbose_name_plural`: "авторы".
- Упорядочивание по полю `name`.

### Модель `Book`
Наследуется от `AuditModel`. Хранит информацию о книгах. Поля:
- `title`: Название книги (строка, максимум 200 символов).
- `author`: Ссылка на автора (`ForeignKey` к `Author`, `on_delete=models.CASCADE`). При удалении автора удаляются все его книги.
- `published_date`: Дата публикации книги (тип `DateField`).
- `description`: Описание книги (текстовое поле).
- `publisher`: Ссылка на издательство (`ForeignKey` к `Publisher`, `on_delete=models.PROTECT`). Удаление издательства запрещено, если с ним связаны книги.
- `stores`: Много-ко-многим связь с моделью `Store` через `ManyToManyField`. Указывает, в каких магазинах доступна книга.

**Мета-данные**:
- `verbose_name`: "книга", `verbose_name_plural`: "книги".
- Упорядочивание по полю `title`.

### Модель `Review`
Наследуется от `AuditModel`. Хранит отзывы о книгах. Поля:
- `rate`: Оценка книги (целое число от 0 до 10, ограничено валидаторами `MinValueValidator` и `MaxValueValidator`).
- `comment`: Текст отзыва (строка, максимум 1000 символов).
- `book`: Ссылка на книгу (`ForeignKey` к `Book`, `on_delete=models.CASCADE`). При удалении книги удаляются все её отзывы.

**Мета-данные**:
- `verbose_name`: "отзыв", `verbose_name_plural`: "отзывы".
- Упорядочивание по названию книги (`book__title`) и оценке (`rate`).

### Модель `Publisher`
Наследуется от `AuditModel`. Хранит информацию об издательствах. Поля:
- `name`: Название издательства (строка, максимум 100 символов).
- `country`: Страна издательства (строка, максимум 100 символов).

**Мета-данные**:
- `verbose_name`: "издательство", `verbose_name_plural`: "издательства".
- Упорядочивание по полям `name` и `country`.

### Модель `Store`
Хранит информацию о магазинах. Поля:
- `name`: Название магазина (строка, максимум 100 символов).
- `city`: Город магазина (строка, максимум 100 символов).
- Связь: Много-ко-многим с моделью `Book` через `ManyToManyField` в модели `Book`.

**Мета-данные**:
- `verbose_name`: "магазин", `verbose_name_plural`: "магазины".
- Упорядочивание по полям `name` и `city`.
- Метод `get_absolute_url`: Возвращает URL для детального просмотра магазина.

### Связи между моделями
- **`Author` → `Book`**: Один ко многим (`ForeignKey` в `Book`). Один автор может иметь много книг.
- **`Publisher` → `Book`**: Один ко многим (`ForeignKey` в `Book`). Одно издательство может издавать много книг.
- **`Book` → `Review`**: Один ко многим (`ForeignKey` в `Review`). Одна книга может иметь много отзывов.
- **`Book` ↔ `Store`**: Много ко многим (`ManyToManyField` в `Book`). Книга может быть доступна в нескольких магазинах, и магазин может продавать много книг.

## 2. Инструкции по созданию тестовых данных через административную панель

Для создания тестовых данных через административную панель Django выполните следующие шаги. Предполагается, что вы уже настроили проект, зарегистрировали модели в `admin.py` и создали суперпользователя (`python manage.py createsuperuser`).

### Шаг 1: Вход в административную панель
1. Запустите сервер разработки: `python manage.py runserver`.
2. Перейдите по адресу `http://127.0.0.1:8000/admin/` и войдите, используя учетные данные суперпользователя.

### Шаг 2: Создание пользователей
1. В разделе **Users** нажмите **Add User**.
2. Создайте пользователя:
   - **Username**: `testuser1`
   - **Password**: Установите пароль, например, `testpassword123`.
3. Сохраните пользователя.
4. Повторите для второго пользователя, например, `testuser2`.

### Шаг 3: Создание издательств
1. В разделе **Publishers** нажмите **Add Publisher**.
2. Заполните поля:
   - **Name**: `Издательство А`
   - **Country**: `Россия`
   - **Creator**: Выберите `testuser1`.
3. Сохраните.
4. Создайте ещё одно издательство:
   - **Name**: `Издательство B`
   - **Country**: `США`
   - **Creator**: Выберите `testuser2`.

### Шаг 4: Создание магазинов
1. В разделе **Stores** нажмите **Add Store**.
2. Заполните поля:
   - **Name**: `Книжный мир`
   - **City**: `Москва`
3. Сохраните.
4. Создайте ещё один магазин:
   - **Name**: `Библиотека`
   - **City**: `Нью-Йорк`

### Шаг 5: Создание авторов
1. В разделе **Authors** нажмите **Add Author**.
2. Заполните поля:
   - **Name**: `Иван Иванов`
   - **Bio**: `Российский писатель, автор романов.`
   - **Creator**: Выберите `testuser1`.
3. Сохраните.
4. Создайте второго автора:
   - **Name**: `John Doe`
   - **Bio**: `Американский писатель, автор детективов.`
   - **Creator**: Выберите `testuser2`.

### Шаг 6: Создание книг
1. В разделе **Books** нажмите **Add Book**.
2. Заполните поля:
   - **Title**: `Роман о времени`
   - **Author**: Выберите `Иван Иванов`.
   - **Published_date**: `2023-05-15`
   - **Description**: `Исторический роман о судьбе.`
   - **Publisher**: Выберите `Издательство А`.
   - **Stores**: Выберите `Книжный мир`.
   - **Creator**: Выберите `testuser1`.
3. Сохраните.
4. Создайте вторую книгу:
   - **Title**: `Тайна ночи`
   - **Author**: Выберите `John Doe`.
   - **Published_date**: `2022-10-20`
   - **Description**: `Детективный триллер.`
   - **Publisher**: Выберите `Издательство B`.
   - **Stores**: Выберите `Библиотека`.
   - **Creator**: Выберите `testuser2`.

### Шаг 7: Создание отзывов
1. В разделе **Reviews** нажмите **Add Review**.
2. Заполните поля:
   - **Book**: Выберите `Роман о времени`.
   - **Rate**: `8`
   - **Comment**: `Отличная книга, рекомендую!`
   - **Creator**: Выберите `testuser1`.
3. Сохраните.
4. Создайте второй отзыв:
   - **Book**: `Тайна ночи`.
   - **Rate**: `9`
   - **Comment**: `Захватывающий сюжет!`
   - **Creator**: Выберите `testuser2`.

### Результат
Теперь у вас есть тестовые данные: 2 пользователя, 2 издательства, 2 магазина, 2 автора, 2 книги и 2 отзыва. Эти данные можно использовать для тестирования запросов.

## 3. Описание запросов и их логики

### `start_page`
- **Логика**: Получает все книги из базы данных с помощью `Book.objects.all()` и передает их в шаблон `index.html`.
- **Результат**: Отображает список всех книг на главной странице.
- **Особенности**: Простой запрос без фильтрации или оптимизации, подходит для небольших баз данных.

### `get_books_by_country`
- **Логика**:
  - Фильтрует книги по стране издательства (`publisher__country=country`).
  - Использует `select_related("author", "publisher")` для оптимизации загрузки связанных данных об авторе и издателе.
  - Использует `prefetch_related("stores")` для оптимизации загрузки связанных магазинов.
  - Аннотирует:
    - `average_review_rate`: Средняя оценка отзывов, округленная до двух знаков (`Round(Avg("review__rate"), 2)`).
    - `available_in_stores`: Количество уникальных магазинов, где доступна книга (`Count("stores", distinct=True)`).
- **Результат**: Отображает список книг, изданных в указанной стране, с их средней оценкой и количеством магазинов.
- **Шаблон**: `books/book_list.html`.

### `get_books_by_city`
- **Логика**:
  - Фильтрует книги по городу магазинов (`stores__city=city`).
  - Использует `Prefetch` для ограничения выборки магазинов только теми, что находятся в указанном городе.
  - Применяет `select_related("author", "publisher")` и `prefetch_related` для оптимизации.
  - Аннотирует:
    - `average_review_rate`: Средняя оценка отзывов.
    - `available_in_stores`: Количество магазинов в указанном городе, где доступна книга (`Count("stores", filter=Q(stores__city=city), distinct=True)`).
- **Результат**: Список книг, доступных в магазинах указанного города, с их средней оценкой и количеством магазинов в городе.
- **Шаблон**: `books/book_list.html`.

### `get_books_by_rating`
- **Логика**:
  - Фильтрует книги, у которых средняя оценка отзывов выше заданного значения (`average_review_rate__gt=rating`).
  - Аннотирует среднюю оценку и количество магазинов, как в предыдущих запросах.
  - Сортирует по средней оценке (по убыванию) и названию книги.
  - Обрабатывает ошибку, если `rating` не является числом, возвращая сообщение об ошибке.
- **Результат**: Список книг с рейтингом выше указанного, отсортированный по рейтингу и названию.
- **Шаблон**: `books/book_list.html`.

### `get_shop_report`
- **Логика**:
  - Получает все магазины с аннотацией количества уникальных книг (`books_counter=Count("book", distinct=True)`).
  - Использует `Prefetch` для загрузки связанных книг с их авторами (`select_related("author")`).
- **Результат**: Отчет, показывающий все магазины и количество книг в каждом.
- **Шаблон**: `books/store_list.html`.

### `get_shop_report_by_published_date`
- **Логика**:
  - Фильтрует магазины, в которых есть книги, изданные не ранее указанного года (`published_date__year__gte=year`).
  - Аннотирует количество книг, удовлетворяющих условию года выпуска.
  - Сортирует магазины по количеству книг (по убыванию).
  - Использует `Prefetch` для оптимизации загрузки книг с авторами и издателями.
- **Результат**: Отчет по магазинам с книгами, изданными не ранее указанного года, с указанием количества таких книг.
- **Шаблон**: `books/store_list.html`.

### `get_store`
- **Логика**:
  - Получает конкретный магазин по его `pk`.
  - Использует `Prefetch` для загрузки связанных книг с авторами, издателями и средней оценкой отзывов.
  - Аннотирует количество книг в магазине через `aggregate`.
- **Результат**: Детальная информация о магазине, включая список книг и их количество.
- **Шаблон**: `books/store_detail.html`.

## 4. Оптимизация запросов с использованием `select_related` и `prefetch_related`

### `select_related`
- **Что делает**: Используется для связей "один-к-одному" и "многие-к-одному" (`ForeignKey`). Выполняет SQL JOIN, чтобы загрузить связанные данные в одном запросе.
- **Применение**:
  - В `get_books_by_country`, `get_books_by_city`, `get_books_by_rating`: `select_related("author", "publisher")` загружает данные об авторе и издателе для каждой книги, снижая количество запросов.
  - В `get_shop_report_by_published_date` и `get_store`: `select_related("author", "publisher")` в `Prefetch` для книг оптимизирует загрузку связанных данных.
- **Эффект**: Вместо отдельных запросов для каждого автора и издателя данные загружаются одним запросом с использованием JOIN.

### `prefetch_related`
- **Что делает**: Используется для связей "многие-ко-многим" и "один-ко-многим" (`ManyToManyField`, обратные `ForeignKey`). Выполняет отдельный запрос для связанных данных и объединяет их в памяти Python.
- **Применение**:
  - В `get_books_by_country` и `get_books_by_rating`: `prefetch_related("stores")` загружает все магазины, связанные с книгами, одним запросом.
  - В `get_books_by_city`: `Prefetch("stores", queryset=Store.objects.filter(city=city))` ограничивает выборку магазинов только нужным городом, снижая объем данных.
  - В `get_shop_report` и `get_shop_report_by_published_date`: `Prefetch("book_set", ...)` загружает книги для каждого магазина с оптимизацией через `select_related`.
  - В `get_store`: `Prefetch` загружает книги магазина с их средней оценкой и связанными авторами/издателями.
- **Эффект**: Снижает количество запросов для получения связанных данных, особенно для связей "многие-ко-многим".

### Пример оптимизации
Без `select_related` и `prefetch_related` запрос `get_books_by_country` мог бы породить сотни запросов для получения авторов, издательств и магазинов для каждой книги. С оптимизацией:
- Один запрос для книг с авторами и издателями (благодаря `select_related`).
- Один запрос для всех магазинов, связанных с этими книгами (благодаря `prefetch_related`).
- Один запрос для вычисления средней оценки отзывов (агрегация через аннотацию).

### Итог
Использование `select_related` и `prefetch_related` минимизирует количество SQL-запросов, что критично для производительности при работе с большими объемами данных. Аннотации (`Avg`, `Count`) дополнительно оптимизируют вычисления, выполняя их на уровне базы данных, а не в Python.